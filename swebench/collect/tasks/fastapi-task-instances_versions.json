[
  {
    "repo": "fastapi/fastapi",
    "pull_number": 435,
    "instance_id": "fastapi__fastapi-435",
    "issue_numbers": ["428", "428"],
    "base_commit": "033bc2a6c9aec3a245eb1f1b4fadb2fbb7a514b8",
    "patch": "diff --git a/fastapi/openapi/utils.py b/fastapi/openapi/utils.py\nindex 9c043103dc0b7..96be89d937fe0 100644\n--- a/fastapi/openapi/utils.py\n+++ b/fastapi/openapi/utils.py\n@@ -43,6 +43,15 @@\n     },\n }\n \n+status_code_ranges: Dict[str, str] = {\n+    \"1XX\": \"Information\",\n+    \"2XX\": \"Success\",\n+    \"3XX\": \"Redirection\",\n+    \"4XX\": \"Client Error\",\n+    \"5XX\": \"Server Error\",\n+    \"default\": \"Default Response\",\n+}\n+\n \n def get_openapi_params(dependant: Dependant) -> List[Field]:\n     flat_dependant = get_flat_dependant(dependant)\n@@ -190,12 +199,14 @@ def get_openapi_path(\n                         response.setdefault(\"content\", {}).setdefault(\n                             \"application/json\", {}\n                         )[\"schema\"] = response_schema\n-                    status_text = http.client.responses.get(int(additional_status_code))\n+                    status_text: Optional[str] = status_code_ranges.get(\n+                        str(additional_status_code).upper()\n+                    ) or http.client.responses.get(int(additional_status_code))\n                     response.setdefault(\n                         \"description\", status_text or \"Additional Response\"\n                     )\n                     operation.setdefault(\"responses\", {})[\n-                        str(additional_status_code)\n+                        str(additional_status_code).upper()\n                     ] = response\n             status_code = str(route.status_code)\n             response_schema = {\"type\": \"string\"}\n",
    "test_patch": "diff --git a/tests/test_additional_responses_bad.py b/tests/test_additional_responses_bad.py\nnew file mode 100644\nindex 0000000000000..fda4755763b3e\n--- /dev/null\n+++ b/tests/test_additional_responses_bad.py\n@@ -0,0 +1,40 @@\n+import pytest\n+from fastapi import FastAPI\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+@app.get(\"/a\", responses={\"hello\": {\"description\": \"Not a valid additional response\"}})\n+async def a():\n+    pass  # pragma: no cover\n+\n+\n+openapi_schema = {\n+    \"openapi\": \"3.0.2\",\n+    \"info\": {\"title\": \"Fast API\", \"version\": \"0.1.0\"},\n+    \"paths\": {\n+        \"/a\": {\n+            \"get\": {\n+                \"responses\": {\n+                    # this is how one would imagine the openapi schema to be\n+                    # but since the key is not valid, openapi.utils.get_openapi will raise ValueError\n+                    \"hello\": {\"description\": \"Not a valid additional response\"},\n+                    \"200\": {\n+                        \"description\": \"Successful Response\",\n+                        \"content\": {\"application/json\": {\"schema\": {}}},\n+                    },\n+                },\n+                \"summary\": \"A\",\n+                \"operationId\": \"a_a_get\",\n+            }\n+        }\n+    },\n+}\n+\n+client = TestClient(app)\n+\n+\n+def test_openapi_schema():\n+    with pytest.raises(ValueError):\n+        client.get(\"/openapi.json\")\ndiff --git a/tests/test_additional_responses_router.py b/tests/test_additional_responses_router.py\nindex 49ef5f04992f4..ce66ead7e0c71 100644\n--- a/tests/test_additional_responses_router.py\n+++ b/tests/test_additional_responses_router.py\n@@ -10,12 +10,24 @@ async def a():\n     return \"a\"\n \n \n-@router.get(\"/b\", responses={502: {\"description\": \"Error 2\"}})\n+@router.get(\n+    \"/b\",\n+    responses={\n+        502: {\"description\": \"Error 2\"},\n+        \"4XX\": {\"description\": \"Error with range, upper\"},\n+    },\n+)\n async def b():\n     return \"b\"\n \n \n-@router.get(\"/c\", responses={501: {\"description\": \"Error 3\"}})\n+@router.get(\n+    \"/c\",\n+    responses={\n+        \"400\": {\"description\": \"Error with str\"},\n+        \"5xx\": {\"description\": \"Error with range, lower\"},\n+    },\n+)\n async def c():\n     return \"c\"\n \n@@ -43,6 +55,7 @@ async def c():\n             \"get\": {\n                 \"responses\": {\n                     \"502\": {\"description\": \"Error 2\"},\n+                    \"4XX\": {\"description\": \"Error with range, upper\"},\n                     \"200\": {\n                         \"description\": \"Successful Response\",\n                         \"content\": {\"application/json\": {\"schema\": {}}},\n@@ -55,7 +68,8 @@ async def c():\n         \"/c\": {\n             \"get\": {\n                 \"responses\": {\n-                    \"501\": {\"description\": \"Error 3\"},\n+                    \"400\": {\"description\": \"Error with str\"},\n+                    \"5XX\": {\"description\": \"Error with range, lower\"},\n                     \"200\": {\n                         \"description\": \"Successful Response\",\n                         \"content\": {\"application/json\": {\"schema\": {}}},\n",
    "problem_statement": "OpenAPI: response keys are limited to be status codes\n**Describe the bug**\r\nAccording to OpenAPI 3 specification, under `responses` dictionary each definition starts with the keys which is either a valid status codes (200, 204, 404, etc.), a [range of codes](https://swagger.io/docs/specification/describing-responses#status-codes) (1XX, 2XX, 3XX, etc.) or the word [\"default\"](https://swagger.io/docs/specification/describing-responses#default).\r\n\r\nIf a path is defined with such response, the server crashes when opening the doc, redoc or openapi.json URLs.\r\n\r\n**To Reproduce**\r\n```python\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom starlette import status\r\nfrom . import schemas\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/customer/{id}',\r\n            status_code=status.HTTP_200_OK,\r\n            response_model=schemas.CustomerDetailsResponse,\r\n            responses={\r\n                '4xx': {'model': schemas.ErrorResponse},\r\n                '5xx': {'model': schemas.ErrorResponse},\r\n            },\r\n            )\r\ndef customer_details(id: str):\r\n    raise HTTPException(status_code=status.HTTP_501_NOT_IMPLEMENTED)\r\n```\r\n\r\n**Expected behavior**\r\nThe openapi.json is created, documentation opens, and the responses show the range / default \r\ndefinitions.\r\n\r\n```yaml\r\n# ...\r\n\"/api/customer/{id}\":\r\n  get:\r\n    responses:\r\n      '200':\r\n        description: Successful Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/CustomerDetailsResponse\"\r\n      4xx:\r\n        description: Additional Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/ErrorResponse\"\r\n      5xx:\r\n        description: Additional Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/ErrorResponse\"\r\n    summary: Customer Details\r\n    operationId: customer_details_api_customer__id__get\r\n    parameters:\r\n    - required: true\r\n      schema:\r\n        title: Id\r\n        type: string\r\n      name: id\r\n      in: path\r\n```\r\n\r\n**Environment:**\r\n - OS: masOS 10.14.6\r\n - Python: 3.6.5\r\n - FastAPI: 0.35.0\nOpenAPI: response keys are limited to be status codes\n**Describe the bug**\r\nAccording to OpenAPI 3 specification, under `responses` dictionary each definition starts with the keys which is either a valid status codes (200, 204, 404, etc.), a [range of codes](https://swagger.io/docs/specification/describing-responses#status-codes) (1XX, 2XX, 3XX, etc.) or the word [\"default\"](https://swagger.io/docs/specification/describing-responses#default).\r\n\r\nIf a path is defined with such response, the server crashes when opening the doc, redoc or openapi.json URLs.\r\n\r\n**To Reproduce**\r\n```python\r\nfrom fastapi import FastAPI, HTTPException\r\nfrom starlette import status\r\nfrom . import schemas\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/customer/{id}',\r\n            status_code=status.HTTP_200_OK,\r\n            response_model=schemas.CustomerDetailsResponse,\r\n            responses={\r\n                '4xx': {'model': schemas.ErrorResponse},\r\n                '5xx': {'model': schemas.ErrorResponse},\r\n            },\r\n            )\r\ndef customer_details(id: str):\r\n    raise HTTPException(status_code=status.HTTP_501_NOT_IMPLEMENTED)\r\n```\r\n\r\n**Expected behavior**\r\nThe openapi.json is created, documentation opens, and the responses show the range / default \r\ndefinitions.\r\n\r\n```yaml\r\n# ...\r\n\"/api/customer/{id}\":\r\n  get:\r\n    responses:\r\n      '200':\r\n        description: Successful Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/CustomerDetailsResponse\"\r\n      4xx:\r\n        description: Additional Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/ErrorResponse\"\r\n      5xx:\r\n        description: Additional Response\r\n        content:\r\n          application/json:\r\n            schema:\r\n              \"$ref\": \"#/components/schemas/ErrorResponse\"\r\n    summary: Customer Details\r\n    operationId: customer_details_api_customer__id__get\r\n    parameters:\r\n    - required: true\r\n      schema:\r\n        title: Id\r\n        type: string\r\n      name: id\r\n      in: path\r\n```\r\n\r\n**Environment:**\r\n - OS: masOS 10.14.6\r\n - Python: 3.6.5\r\n - FastAPI: 0.35.0\n",
    "hints_text": "\n",
    "created_at": "2019-08-13T07:07:42Z",
    "version": "0.35",
    "FAIL_TO_PASS": ["tests/test_additional_responses_router.py::test_openapi_schema"],
    "PASS_TO_PASS": [
      "tests/test_additional_responses_bad.py::test_openapi_schema",
      "tests/test_additional_responses_router.py::test_a",
      "tests/test_additional_responses_router.py::test_b", 
      "tests/test_additional_responses_router.py::test_c"]
  },
  {
    "repo": "fastapi/fastapi",
    "pull_number": 538,
    "instance_id": "fastapi__fastapi-538",
    "issue_numbers": ["539"],
    "base_commit": "f5ccb3c35d4ee87f61b0c03c8e4b0c24edffac60",
    "patch": "diff --git a/fastapi/routing.py b/fastapi/routing.py\nindex aeafd07187e81..51b1ef9d6e137 100644\n--- a/fastapi/routing.py\n+++ b/fastapi/routing.py\n@@ -345,8 +345,10 @@ def add_api_route(\n         include_in_schema: bool = True,\n         response_class: Type[Response] = None,\n         name: str = None,\n+        route_class_override: Optional[Type[APIRoute]] = None,\n     ) -> None:\n-        route = self.route_class(\n+        route_class = route_class_override or self.route_class\n+        route = route_class(\n             path,\n             endpoint=endpoint,\n             response_model=response_model,\n@@ -484,6 +486,7 @@ def include_router(\n                     include_in_schema=route.include_in_schema,\n                     response_class=route.response_class or default_response_class,\n                     name=route.name,\n+                    route_class_override=type(route),\n                 )\n             elif isinstance(route, routing.Route):\n                 self.add_route(\n",
    "test_patch": "diff --git a/tests/test_custom_route_class.py b/tests/test_custom_route_class.py\nnew file mode 100644\nindex 0000000000000..8bbf88ad30f2c\n--- /dev/null\n+++ b/tests/test_custom_route_class.py\n@@ -0,0 +1,114 @@\n+import pytest\n+from fastapi import APIRouter, FastAPI\n+from fastapi.routing import APIRoute\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+class APIRouteA(APIRoute):\n+    x_type = \"A\"\n+\n+\n+class APIRouteB(APIRoute):\n+    x_type = \"B\"\n+\n+\n+class APIRouteC(APIRoute):\n+    x_type = \"C\"\n+\n+\n+router_a = APIRouter(route_class=APIRouteA)\n+router_b = APIRouter(route_class=APIRouteB)\n+router_c = APIRouter(route_class=APIRouteC)\n+\n+\n+@router_a.get(\"/\")\n+def get_a():\n+    return {\"msg\": \"A\"}\n+\n+\n+@router_b.get(\"/\")\n+def get_b():\n+    return {\"msg\": \"B\"}\n+\n+\n+@router_c.get(\"/\")\n+def get_c():\n+    return {\"msg\": \"C\"}\n+\n+\n+router_b.include_router(router=router_c, prefix=\"/c\")\n+router_a.include_router(router=router_b, prefix=\"/b\")\n+app.include_router(router=router_a, prefix=\"/a\")\n+\n+\n+client = TestClient(app)\n+\n+openapi_schema = {\n+    \"openapi\": \"3.0.2\",\n+    \"info\": {\"title\": \"Fast API\", \"version\": \"0.1.0\"},\n+    \"paths\": {\n+        \"/a/\": {\n+            \"get\": {\n+                \"responses\": {\n+                    \"200\": {\n+                        \"description\": \"Successful Response\",\n+                        \"content\": {\"application/json\": {\"schema\": {}}},\n+                    }\n+                },\n+                \"summary\": \"Get A\",\n+                \"operationId\": \"get_a_a__get\",\n+            }\n+        },\n+        \"/a/b/\": {\n+            \"get\": {\n+                \"responses\": {\n+                    \"200\": {\n+                        \"description\": \"Successful Response\",\n+                        \"content\": {\"application/json\": {\"schema\": {}}},\n+                    }\n+                },\n+                \"summary\": \"Get B\",\n+                \"operationId\": \"get_b_a_b__get\",\n+            }\n+        },\n+        \"/a/b/c/\": {\n+            \"get\": {\n+                \"responses\": {\n+                    \"200\": {\n+                        \"description\": \"Successful Response\",\n+                        \"content\": {\"application/json\": {\"schema\": {}}},\n+                    }\n+                },\n+                \"summary\": \"Get C\",\n+                \"operationId\": \"get_c_a_b_c__get\",\n+            }\n+        },\n+    },\n+}\n+\n+\n+@pytest.mark.parametrize(\n+    \"path,expected_status,expected_response\",\n+    [\n+        (\"/a\", 200, {\"msg\": \"A\"}),\n+        (\"/a/b\", 200, {\"msg\": \"B\"}),\n+        (\"/a/b/c\", 200, {\"msg\": \"C\"}),\n+        (\"/openapi.json\", 200, openapi_schema),\n+    ],\n+)\n+def test_get_path(path, expected_status, expected_response):\n+    response = client.get(path)\n+    assert response.status_code == expected_status\n+    assert response.json() == expected_response\n+\n+\n+def test_route_classes():\n+    routes = {}\n+    r: APIRoute\n+    for r in app.router.routes:\n+        routes[r.path] = r\n+    assert routes[\"/a/\"].x_type == \"A\"\n+    assert routes[\"/a/b/\"].x_type == \"B\"\n+    assert routes[\"/a/b/c/\"].x_type == \"C\"\n",
    "problem_statement": "route_class not preserved when calling APIRouter.include_router\n**Describe the bug**\r\n\r\nWhen calling `APIRouter.include_router`, the class of the included routes should be preserved. Right now, this is not the case -- the `route_class` of the parent router is used. This means that the `route_class` is lost on inclusion if one isn't careful. Worse, it means that even if you manually create a router with multiple route-types present, there is no way to include that router in another without changing the route type of some of the routes.\r\n\r\nSee the `include_typed_router` function from #521 for an example of how this currently requires a workaround.\r\n\r\nI have addressed this in the short PR #538, but wanted to create an issue for discussion in case there is any reason to preserve the current behavior.\n",
    "hints_text": "",
    "created_at": "2019-09-17T04:51:53Z",
    "version": "0.39",
    "FAIL_TO_PASS": [
      "tests/test_custom_route_class.py::test_route_classes"
  ],
    "PASS_TO_PASS": [
      "tests/test_custom_route_class.py::test_get_path[/a-200-expected_response0]",
      "tests/test_custom_route_class.py::test_get_path[/a/b-200-expected_response1]",
      "tests/test_custom_route_class.py::test_get_path[/a/b/c-200-expected_response2]",
      "tests/test_custom_route_class.py::test_get_path[/openapi.json-200-expected_response3]"
  ]
  },
  {
    "repo": "fastapi/fastapi",
    "pull_number": 856,
    "instance_id": "fastapi__fastapi-856",
    "issue_numbers": ["842"],
    "base_commit": "3eca945bd17600a0be6eae1d8fd93ba8f9805006",
    "patch": "diff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 956fffff472de..a1cc0b9808d4c 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -629,9 +629,9 @@ async def request_body_to_args(\n         for field in required_params:\n             value: Any = None\n             if received_body is not None:\n-                if field.shape in sequence_shapes and isinstance(\n-                    received_body, FormData\n-                ):\n+                if (\n+                    field.shape in sequence_shapes or field.type_ in sequence_types\n+                ) and isinstance(received_body, FormData):\n                     value = received_body.getlist(field.alias)\n                 else:\n                     value = received_body.get(field.alias)\n",
    "test_patch": "diff --git a/tests/test_forms_from_non_typing_sequences.py b/tests/test_forms_from_non_typing_sequences.py\nnew file mode 100644\nindex 0000000000000..0e47e906ae75b\n--- /dev/null\n+++ b/tests/test_forms_from_non_typing_sequences.py\n@@ -0,0 +1,46 @@\n+from fastapi import FastAPI, Form\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+@app.post(\"/form/python-list\")\n+def post_form_param_list(items: list = Form(...)):\n+    return items\n+\n+\n+@app.post(\"/form/python-set\")\n+def post_form_param_set(items: set = Form(...)):\n+    return items\n+\n+\n+@app.post(\"/form/python-tuple\")\n+def post_form_param_tuple(items: tuple = Form(...)):\n+    return items\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_python_list_param_as_form():\n+    response = client.post(\n+        \"/form/python-list\", data={\"items\": [\"first\", \"second\", \"third\"]}\n+    )\n+    assert response.status_code == 200\n+    assert response.json() == [\"first\", \"second\", \"third\"]\n+\n+\n+def test_python_set_param_as_form():\n+    response = client.post(\n+        \"/form/python-set\", data={\"items\": [\"first\", \"second\", \"third\"]}\n+    )\n+    assert response.status_code == 200\n+    assert set(response.json()) == {\"first\", \"second\", \"third\"}\n+\n+\n+def test_python_tuple_param_as_form():\n+    response = client.post(\n+        \"/form/python-tuple\", data={\"items\": [\"first\", \"second\", \"third\"]}\n+    )\n+    assert response.status_code == 200\n+    assert response.json() == [\"first\", \"second\", \"third\"]\n",
    "problem_statement": "Support repeated key=value in form data\n### Is your feature request related to a problem\r\n\r\nYes.\r\n\r\nGiven some URL encoded data like this...\r\n\r\n```\r\nchoices=parrot&choices=spider\r\n```\r\n\r\n...only the last key=value wins.\r\n\r\nThis does not work like I expected:\r\n```python\r\nchoices: list = Form(...)\r\n```\r\n\r\nYou can only validate against the last value.\r\n\r\n### The solution you would like\r\n\r\nPerhaps FastAPI should collect repeated keys in the 2-tuple list that `request.form()` gives and assign those values as a list to the same key before validation happens.\r\n\r\n\r\n\n",
    "hints_text": "Hey @StephenCarboni, parameters in the URL are part of a querystring and you can get and validate them as described here: https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#query-parameter-list-multiple-values\r\nAs far as I understand, `Form()` is using only for request body\nOh, sorry, looks like I misread you message.\nAnyway, I think this issue better be created in the starlette repo, because the `request` is an object from starlette.\nI am a little surprised that `choices=parrot&choices=spider` doesn't work; if I recall correctly it definitely works for query parameters, and is how you would send a list of values.\r\n\r\nThe logic for form data parsing is in the `starlette.requests.Request.form` method, and delegates to [`python-multipart`](https://github.com/andrew-d/python-multipart), so you can look for the specific logic there.\r\n\r\n(Since it uses an entirely different library for parsing, it ultimately isn't THAT surprising that the logic might be different.)",
    "created_at": "2020-01-14T03:48:12Z",
    "version": "0.46",
    "FAIL_TO_PASS": [
      "tests/test_forms_from_non_typing_sequences.py::test_python_list_param_as_form",
      "tests/test_forms_from_non_typing_sequences.py::test_python_set_param_as_form",
      "tests/test_forms_from_non_typing_sequences.py::test_python_tuple_param_as_form"
  ],
    "PASS_TO_PASS": []
  },
  {
    "repo": "fastapi/fastapi",
    "pull_number": 756,
    "instance_id": "fastapi__fastapi-756",
    "issue_numbers": ["755"],
    "base_commit": "861ed37c9784c4aefa646c875ed0353c5699d6d8",
    "patch": "diff --git a/fastapi/encoders.py b/fastapi/encoders.py\nindex 25cd0b0269ad4..765bb18e08a24 100644\n--- a/fastapi/encoders.py\n+++ b/fastapi/encoders.py\n@@ -1,6 +1,6 @@\n from enum import Enum\n from types import GeneratorType\n-from typing import Any, Dict, List, Set, Union\n+from typing import Any, Callable, Dict, List, Set, Tuple, Union\n \n from fastapi.utils import PYDANTIC_1, logger\n from pydantic import BaseModel\n@@ -10,6 +10,21 @@\n DictIntStrAny = Dict[Union[int, str], Any]\n \n \n+def generate_encoders_by_class_tuples(\n+    type_encoder_map: Dict[Any, Callable]\n+) -> Dict[Callable, Tuple]:\n+    encoders_by_classes: Dict[Callable, List] = {}\n+    for type_, encoder in type_encoder_map.items():\n+        encoders_by_classes.setdefault(encoder, []).append(type_)\n+    encoders_by_class_tuples: Dict[Callable, Tuple] = {}\n+    for encoder, classes in encoders_by_classes.items():\n+        encoders_by_class_tuples[encoder] = tuple(classes)\n+    return encoders_by_class_tuples\n+\n+\n+encoders_by_class_tuples = generate_encoders_by_class_tuples(ENCODERS_BY_TYPE)\n+\n+\n def jsonable_encoder(\n     obj: Any,\n     include: Union[SetIntStr, DictIntStrAny] = None,\n@@ -105,24 +120,31 @@ def jsonable_encoder(\n                 )\n             )\n         return encoded_list\n+\n+    if custom_encoder:\n+        if type(obj) in custom_encoder:\n+            return custom_encoder[type(obj)](obj)\n+        else:\n+            for encoder_type, encoder in custom_encoder.items():\n+                if isinstance(obj, encoder_type):\n+                    return encoder(obj)\n+\n+    if type(obj) in ENCODERS_BY_TYPE:\n+        return ENCODERS_BY_TYPE[type(obj)](obj)\n+    for encoder, classes_tuple in encoders_by_class_tuples.items():\n+        if isinstance(obj, classes_tuple):\n+            return encoder(obj)\n+\n     errors: List[Exception] = []\n     try:\n-        if custom_encoder and type(obj) in custom_encoder:\n-            encoder = custom_encoder[type(obj)]\n-        else:\n-            encoder = ENCODERS_BY_TYPE[type(obj)]\n-        return encoder(obj)\n-    except KeyError as e:\n+        data = dict(obj)\n+    except Exception as e:\n         errors.append(e)\n         try:\n-            data = dict(obj)\n+            data = vars(obj)\n         except Exception as e:\n             errors.append(e)\n-            try:\n-                data = vars(obj)\n-            except Exception as e:\n-                errors.append(e)\n-                raise ValueError(errors)\n+            raise ValueError(errors)\n     return jsonable_encoder(\n         data,\n         by_alias=by_alias,\n",
    "test_patch": "diff --git a/tests/test_inherited_custom_class.py b/tests/test_inherited_custom_class.py\nnew file mode 100644\nindex 0000000000000..a9f6738983591\n--- /dev/null\n+++ b/tests/test_inherited_custom_class.py\n@@ -0,0 +1,73 @@\n+import uuid\n+\n+import pytest\n+from fastapi import FastAPI\n+from pydantic import BaseModel\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+class MyUuid:\n+    def __init__(self, uuid_string: str):\n+        self.uuid = uuid_string\n+\n+    def __str__(self):\n+        return self.uuid\n+\n+    @property\n+    def __class__(self):\n+        return uuid.UUID\n+\n+    @property\n+    def __dict__(self):\n+        \"\"\"Spoof a missing __dict__ by raising TypeError, this is how\n+        asyncpg.pgroto.pgproto.UUID behaves\"\"\"\n+        raise TypeError(\"vars() argument must have __dict__ attribute\")\n+\n+\n+@app.get(\"/fast_uuid\")\n+def return_fast_uuid():\n+    # I don't want to import asyncpg for this test so I made my own UUID\n+    # Import asyncpg and uncomment the two lines below for the actual bug\n+\n+    # from asyncpg.pgproto import pgproto\n+    # asyncpg_uuid = pgproto.UUID(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\n+\n+    asyncpg_uuid = MyUuid(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\n+    assert isinstance(asyncpg_uuid, uuid.UUID)\n+    assert type(asyncpg_uuid) != uuid.UUID\n+    with pytest.raises(TypeError):\n+        vars(asyncpg_uuid)\n+    return {\"fast_uuid\": asyncpg_uuid}\n+\n+\n+class SomeCustomClass(BaseModel):\n+    class Config:\n+        arbitrary_types_allowed = True\n+        json_encoders = {uuid.UUID: str}\n+\n+    a_uuid: MyUuid\n+\n+\n+@app.get(\"/get_custom_class\")\n+def return_some_user():\n+    # Test that the fix also works for custom pydantic classes\n+    return SomeCustomClass(a_uuid=MyUuid(\"b8799909-f914-42de-91bc-95c819218d01\"))\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_dt():\n+    with client:\n+        response_simple = client.get(\"/fast_uuid\")\n+        response_pydantic = client.get(\"/get_custom_class\")\n+\n+    assert response_simple.json() == {\n+        \"fast_uuid\": \"a10ff360-3b1e-4984-a26f-d3ab460bdb51\"\n+    }\n+\n+    assert response_pydantic.json() == {\n+        \"a_uuid\": \"b8799909-f914-42de-91bc-95c819218d01\"\n+    }\n",
    "problem_statement": "asyncpg uuid implementation not recognized by fastapi because of too strict typechecking\n### Describe the bug\r\n\r\nAn alternative implementation of the `UUID` type is not serialized by fastapi but throws an error instead. This is because it is of type `asyncpg.pgproto.pgproto.UUID` instead of type `uuid.UUID`. However it is implemented in such a way that it does the exact same things as the regular UUID but just faster. Also,\r\n```python\r\nisinstance(asyncpg.pgproto.pgproto.UUID(), uuid.UUID) == True\r\n```\r\nthis should make fastapi able to recognize it as a uuid.\r\n\r\n### To Reproduce\r\n1. Create a file called uuid_error.py with:\r\n\r\n```Python\r\nimport uuid\r\n\r\nfrom fastapi import FastAPI\r\nfrom asyncpg.pgproto import pgproto\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/normal_uuid\")\r\ndef return_normal_uuid():\r\n    regular_uuid = uuid.UUID(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\r\n    assert isinstance(regular_uuid, uuid.UUID)\r\n    return {\"normal_uuid\": regular_uuid}\r\n\r\n\r\n@app.get(\"/fast_uuid\")\r\ndef return_fast_uuid():\r\n    asyncpg_uuid = pgproto.UUID(\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\")\r\n    assert isinstance(asyncpg_uuid, uuid.UUID)\r\n    return {\"fast_uuid\": asyncpg_uuid}\r\n```\r\n2. Run it with uvicorn uuid_error:app\r\n3. Open the browser and call the endpoint `/fast_uuid`.\r\n4. It returns 'internal server error' .\r\n5. But I expected it to return `{\"fast_uuid\":\"a10ff360-3b1e-4984-a26f-d3ab460bdb51\"}`.\r\n\r\n### Expected behavior\r\n\r\nI expected fastapi to jsonify the uuid and send, but instead it returns 'internal server error'. The precise error being thrown in the server is:\r\n```\r\nValueError: [KeyError(<class 'asyncpg.pgproto.pgproto.UUID'>), TypeError(\"'asyncpg.pgproto.pgproto.UUID' object is not iterable\"), TypeError('vars() argument must have __dict__ attribute')]\r\n```\r\n\r\n### Environment\r\n\r\n- OS: Linux Mint 19 Tara\r\n- FastAPI Version: 0.44.0\r\n- Python version: 3.8.0\r\n\r\n### Additional context\r\n\r\nI initially made an issue in the asyncpg repo asking them if they could fix it: https://github.com/MagicStack/asyncpg/issues/512 I think it's usefull as additional context for this issue.\r\nThe problem can be solved here in the fastapi code by improving the code a little. I'm working on a PR, this line seems to be the issue:\r\nhttps://github.com/tiangolo/fastapi/blob/c200bc2240d48a4a27e96fba536351038eafc44f/fastapi/encoders.py#L113\r\nI think it shouldn't use `type()` but it should instead use `isinstance()` this will make for slightly looser typechecking but I think that might be a good thing in this case?\r\n\n",
    "hints_text": "",
    "created_at": "2019-11-30T09:57:26Z",
    "version": "0.45",
    "FAIL_TO_PASS": [
      "tests/test_inherited_custom_class.py::test_dt"
  ],
    "PASS_TO_PASS": []
  },
  {
    "repo": "fastapi/fastapi",
    "pull_number": 454,
    "instance_id": "fastapi__fastapi-454",
    "issue_numbers": ["265"],
    "base_commit": "033bc2a6c9aec3a245eb1f1b4fadb2fbb7a514b8",
    "patch": "diff --git a/fastapi/utils.py b/fastapi/utils.py\nindex de0260615ee00..17a16b5227687 100644\n--- a/fastapi/utils.py\n+++ b/fastapi/utils.py\n@@ -1,4 +1,5 @@\n import re\n+from dataclasses import is_dataclass\n from typing import Any, Dict, List, Sequence, Set, Type, cast\n \n from fastapi import routing\n@@ -52,6 +53,8 @@ def get_path_param_names(path: str) -> Set[str]:\n \n def create_cloned_field(field: Field) -> Field:\n     original_type = field.type_\n+    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n+        original_type = original_type.__pydantic_model__  # type: ignore\n     use_type = original_type\n     if lenient_issubclass(original_type, BaseModel):\n         original_type = cast(Type[BaseModel], original_type)\n",
    "test_patch": "diff --git a/tests/test_serialize_response.py b/tests/test_serialize_response.py\nindex c0382b899438a..5fff871f0f0ca 100644\n--- a/tests/test_serialize_response.py\n+++ b/tests/test_serialize_response.py\n@@ -1,8 +1,7 @@\n from typing import List\n \n-import pytest\n from fastapi import FastAPI\n-from pydantic import BaseModel, ValidationError\n+from pydantic import BaseModel\n from starlette.testclient import TestClient\n \n app = FastAPI()\n@@ -14,38 +13,45 @@ class Item(BaseModel):\n     owner_ids: List[int] = None\n \n \n-@app.get(\"/items/invalid\", response_model=Item)\n-def get_invalid():\n-    return {\"name\": \"invalid\", \"price\": \"foo\"}\n+@app.get(\"/items/valid\", response_model=Item)\n+def get_valid():\n+    return {\"name\": \"valid\", \"price\": 1.0}\n \n \n-@app.get(\"/items/innerinvalid\", response_model=Item)\n-def get_innerinvalid():\n-    return {\"name\": \"double invalid\", \"price\": \"foo\", \"owner_ids\": [\"foo\", \"bar\"]}\n+@app.get(\"/items/coerce\", response_model=Item)\n+def get_coerce():\n+    return {\"name\": \"coerce\", \"price\": \"1.0\"}\n \n \n-@app.get(\"/items/invalidlist\", response_model=List[Item])\n-def get_invalidlist():\n+@app.get(\"/items/validlist\", response_model=List[Item])\n+def get_validlist():\n     return [\n         {\"name\": \"foo\"},\n-        {\"name\": \"bar\", \"price\": \"bar\"},\n-        {\"name\": \"baz\", \"price\": \"baz\"},\n+        {\"name\": \"bar\", \"price\": 1.0},\n+        {\"name\": \"baz\", \"price\": 2.0, \"owner_ids\": [1, 2, 3]},\n     ]\n \n \n client = TestClient(app)\n \n \n-def test_invalid():\n-    with pytest.raises(ValidationError):\n-        client.get(\"/items/invalid\")\n+def test_valid():\n+    response = client.get(\"/items/valid\")\n+    response.raise_for_status()\n+    assert response.json() == {\"name\": \"valid\", \"price\": 1.0, \"owner_ids\": None}\n \n \n-def test_double_invalid():\n-    with pytest.raises(ValidationError):\n-        client.get(\"/items/innerinvalid\")\n+def test_coerce():\n+    response = client.get(\"/items/coerce\")\n+    response.raise_for_status()\n+    assert response.json() == {\"name\": \"coerce\", \"price\": 1.0, \"owner_ids\": None}\n \n \n-def test_invalid_list():\n-    with pytest.raises(ValidationError):\n-        client.get(\"/items/invalidlist\")\n+def test_validlist():\n+    response = client.get(\"/items/validlist\")\n+    response.raise_for_status()\n+    assert response.json() == [\n+        {\"name\": \"foo\", \"price\": None, \"owner_ids\": None},\n+        {\"name\": \"bar\", \"price\": 1.0, \"owner_ids\": None},\n+        {\"name\": \"baz\", \"price\": 2.0, \"owner_ids\": [1, 2, 3]},\n+    ]\ndiff --git a/tests/test_serialize_response_dataclass.py b/tests/test_serialize_response_dataclass.py\nnew file mode 100644\nindex 0000000000000..ee701f9696f77\n--- /dev/null\n+++ b/tests/test_serialize_response_dataclass.py\n@@ -0,0 +1,58 @@\n+from typing import List\n+\n+from fastapi import FastAPI\n+from pydantic.dataclasses import dataclass\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+@dataclass\n+class Item:\n+    name: str\n+    price: float = None\n+    owner_ids: List[int] = None\n+\n+\n+@app.get(\"/items/valid\", response_model=Item)\n+def get_valid():\n+    return {\"name\": \"valid\", \"price\": 1.0}\n+\n+\n+@app.get(\"/items/coerce\", response_model=Item)\n+def get_coerce():\n+    return {\"name\": \"coerce\", \"price\": \"1.0\"}\n+\n+\n+@app.get(\"/items/validlist\", response_model=List[Item])\n+def get_validlist():\n+    return [\n+        {\"name\": \"foo\"},\n+        {\"name\": \"bar\", \"price\": 1.0},\n+        {\"name\": \"baz\", \"price\": 2.0, \"owner_ids\": [1, 2, 3]},\n+    ]\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_valid():\n+    response = client.get(\"/items/valid\")\n+    response.raise_for_status()\n+    assert response.json() == {\"name\": \"valid\", \"price\": 1.0, \"owner_ids\": None}\n+\n+\n+def test_coerce():\n+    response = client.get(\"/items/coerce\")\n+    response.raise_for_status()\n+    assert response.json() == {\"name\": \"coerce\", \"price\": 1.0, \"owner_ids\": None}\n+\n+\n+def test_validlist():\n+    response = client.get(\"/items/validlist\")\n+    response.raise_for_status()\n+    assert response.json() == [\n+        {\"name\": \"foo\", \"price\": None, \"owner_ids\": None},\n+        {\"name\": \"bar\", \"price\": 1.0, \"owner_ids\": None},\n+        {\"name\": \"baz\", \"price\": 2.0, \"owner_ids\": [1, 2, 3]},\n+    ]\ndiff --git a/tests/test_validate_response.py b/tests/test_validate_response.py\nnew file mode 100644\nindex 0000000000000..c0382b899438a\n--- /dev/null\n+++ b/tests/test_validate_response.py\n@@ -0,0 +1,51 @@\n+from typing import List\n+\n+import pytest\n+from fastapi import FastAPI\n+from pydantic import BaseModel, ValidationError\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+class Item(BaseModel):\n+    name: str\n+    price: float = None\n+    owner_ids: List[int] = None\n+\n+\n+@app.get(\"/items/invalid\", response_model=Item)\n+def get_invalid():\n+    return {\"name\": \"invalid\", \"price\": \"foo\"}\n+\n+\n+@app.get(\"/items/innerinvalid\", response_model=Item)\n+def get_innerinvalid():\n+    return {\"name\": \"double invalid\", \"price\": \"foo\", \"owner_ids\": [\"foo\", \"bar\"]}\n+\n+\n+@app.get(\"/items/invalidlist\", response_model=List[Item])\n+def get_invalidlist():\n+    return [\n+        {\"name\": \"foo\"},\n+        {\"name\": \"bar\", \"price\": \"bar\"},\n+        {\"name\": \"baz\", \"price\": \"baz\"},\n+    ]\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_invalid():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/invalid\")\n+\n+\n+def test_double_invalid():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/innerinvalid\")\n+\n+\n+def test_invalid_list():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/invalidlist\")\ndiff --git a/tests/test_validate_response_dataclass.py b/tests/test_validate_response_dataclass.py\nnew file mode 100644\nindex 0000000000000..4a066416a6ab1\n--- /dev/null\n+++ b/tests/test_validate_response_dataclass.py\n@@ -0,0 +1,53 @@\n+from typing import List\n+\n+import pytest\n+from fastapi import FastAPI\n+from pydantic import ValidationError\n+from pydantic.dataclasses import dataclass\n+from starlette.testclient import TestClient\n+\n+app = FastAPI()\n+\n+\n+@dataclass\n+class Item:\n+    name: str\n+    price: float = None\n+    owner_ids: List[int] = None\n+\n+\n+@app.get(\"/items/invalid\", response_model=Item)\n+def get_invalid():\n+    return {\"name\": \"invalid\", \"price\": \"foo\"}\n+\n+\n+@app.get(\"/items/innerinvalid\", response_model=Item)\n+def get_innerinvalid():\n+    return {\"name\": \"double invalid\", \"price\": \"foo\", \"owner_ids\": [\"foo\", \"bar\"]}\n+\n+\n+@app.get(\"/items/invalidlist\", response_model=List[Item])\n+def get_invalidlist():\n+    return [\n+        {\"name\": \"foo\"},\n+        {\"name\": \"bar\", \"price\": \"bar\"},\n+        {\"name\": \"baz\", \"price\": \"baz\"},\n+    ]\n+\n+\n+client = TestClient(app)\n+\n+\n+def test_invalid():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/invalid\")\n+\n+\n+def test_double_invalid():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/innerinvalid\")\n+\n+\n+def test_invalid_list():\n+    with pytest.raises(ValidationError):\n+        client.get(\"/items/invalidlist\")\n",
    "problem_statement": "Add support for Pydantic's dataclasses\n**Describe the question**\r\nI am using a  pydantic.dataclasses.dataclass as a response_model of my fast api route.\r\n\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass Foo:\r\n    bar: int\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/foo', response_model=Foo)\r\ndef get_bar() -> Foo:\r\n    return Foo(bar=1)\r\n```\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Create a file **app.py** with the above code.\r\n2. Start the app: `uvicorn app:app`\r\n3. Open the browser and go to **localhost:8000/foo**\r\n4. See error: \r\n```\r\npydantic.error_wrappers.ValidationError: 1 validation error\r\nresponse\r\n  __init__() got an unexpected keyword argument '__initialised__' (type=type_error)\r\n```\r\n\r\n**Expected behavior**\r\nNo validation error and serialized json does not contain any keys `__initialised__`.\r\n\r\n\r\n**Environment:**\r\n - OS: Linux\r\n - FastAPI Version 0.25.0\r\n- Python version 3.7.3\r\n\n",
    "hints_text": "**Possible solution**\r\n\r\nAdd the following to jsonable_encoder in fastapi.encoders:\r\n\r\n```\r\nfrom dataclasses import is_dataclass, asdict\r\n\r\ndef jsonable_encoder(\r\n    obj: Any,\r\n    include: Set[str] = None,\r\n    exclude: Set[str] = set(),\r\n    by_alias: bool = True,\r\n    skip_defaults: bool = False,\r\n    include_none: bool = True,\r\n    custom_encoder: dict = {},\r\n    sqlalchemy_safe: bool = True,\r\n) -> Any:\r\n...\r\n    if is_dataclass(obj):\r\n        return asdict(obj)\r\n```\nThank you. Pydantic's dataclasses are not supported yet. They probably will be at some point.\nAny updates on this?\nUsing pydantic BaseModel vs dataclass causes tremendous slowdown as well in my codebase.\n@manojlds which one is slower?\n\ud83d\udc4d for this.  I have a backend code base that heavily relies on pydantic dataclasses.\r\n\r\nJust a thought, the way pydantic dataclasses are handled is by putting the `BaseModel` subclass at `cls.__pydantic_model__`, e.g.:\r\n\r\n```python\r\nfrom pydantic.dataclasses import dataclass\r\nfrom pydantic import BaseModel\r\n\r\n@dataclass\r\nclass Foobar:\r\n    pass\r\n\r\nassert issubclass(Foobar.__pydantic_model__, BaseModel)\r\n```\r\n\r\nCould this be solved with a simple:\r\n```python\r\nif isdataclass(cls) and hasattr(cls, \"__pydantic_model__\"):\r\n    cls = cls.__pydantic_model__\r\n```\r\nSomewhere?\nMaybe part of https://github.com/tiangolo/fastapi/blob/master/fastapi/utils.py#L53 ?",
    "created_at": "2019-08-21T17:34:14Z",
    "version": "0.35",
    "FAIL_TO_PASS": [
      "tests/test_serialize_response_dataclass.py::test_valid",
      "tests/test_serialize_response_dataclass.py::test_coerce", 
      "tests/test_serialize_response_dataclass.py::test_validlist"
  ],
    "PASS_TO_PASS": [
      "tests/test_serialize_response.py::test_valid",
      "tests/test_serialize_response.py::test_coerce",
      "tests/test_serialize_response.py::test_validlist",
      "tests/test_validate_response.py::test_invalid",
      "tests/test_validate_response.py::test_double_invalid", 
      "tests/test_validate_response.py::test_invalid_list",
      "tests/test_validate_response_dataclass.py::test_invalid",
      "tests/test_validate_response_dataclass.py::test_double_invalid",
      "tests/test_validate_response_dataclass.py::test_invalid_list"
  ]
    
  }
]
